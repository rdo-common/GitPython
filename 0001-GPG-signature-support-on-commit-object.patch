diff -uNr GitPython-0.3.2.RC1.orig/git/objects/commit.py GitPython-0.3.2.RC1/git/objects/commit.py
--- GitPython-0.3.2.RC1.orig/git/objects/commit.py	2011-06-14 02:31:14.000000000 +0400
+++ GitPython-0.3.2.RC1/git/objects/commit.py	2013-12-07 13:19:10.111948329 +0400
@@ -57,12 +57,12 @@
 	__slots__ = ("tree",
 				 "author", "authored_date", "author_tz_offset",
 				 "committer", "committed_date", "committer_tz_offset",
-				 "message", "parents", "encoding")
+				 "message", "parents", "encoding", "gpgsig")
 	_id_attribute_ = "binsha"
 	
 	def __init__(self, repo, binsha, tree=None, author=None, authored_date=None, author_tz_offset=None,
 				 committer=None, committed_date=None, committer_tz_offset=None, 
-				 message=None,  parents=None, encoding=None):
+				 message=None,  parents=None, encoding=None, gpgsig=None):
 		"""Instantiate a new Commit. All keyword arguments taking None as default will 
 		be implicitly set on first query. 
 		
@@ -120,6 +120,7 @@
 			self.parents = parents
 		if encoding is not None:
 			self.encoding = encoding
+		self.gpgsig = gpgsig
 		
 	@classmethod
 	def _get_intermediate_items(cls, commit):
@@ -394,6 +395,11 @@
 		if self.encoding != self.default_encoding:
 			write("encoding %s\n" % self.encoding)
 		
+		if self.gpgsig:
+			write("gpgsig")
+			for sigline in self.gpgsig.rstrip("\n").split("\n"):
+				write(" "+sigline+"\n")
+		
 		write("\n")
 		
 		# write plain bytes, be sure its encoded according to our encoding
@@ -429,14 +435,26 @@
 		# now we can have the encoding line, or an empty line followed by the optional
 		# message.
 		self.encoding = self.default_encoding
-		# read encoding or empty line to separate message
-		enc = readline()
-		enc = enc.strip()
-		if enc:
-			self.encoding = enc[enc.find(' ')+1:]
-			# now comes the message separator 
-			readline()
-		# END handle encoding
+		# read headers
+		buf = readline().strip()
+		while buf != "":
+			if buf[0:10] == "encoding ":
+				self.encoding = buf[buf.find(' ')+1:]
+			elif buf[0:7] == "gpgsig ":
+				sig = buf[buf.find(' ')+1:] + "\n"
+				is_next_header = False
+				while True:
+					sigbuf = readline()
+					if sigbuf == "": break
+					if sigbuf[0:1] != " ":
+						buf = sigbuf.strip()
+						is_next_header = True
+						break
+					sig += sigbuf[1:]
+				self.gpgsig = sig.rstrip("\n")
+				if is_next_header:
+					continue
+			buf = readline().strip()
 		
 		# decode the authors name
 		try:
